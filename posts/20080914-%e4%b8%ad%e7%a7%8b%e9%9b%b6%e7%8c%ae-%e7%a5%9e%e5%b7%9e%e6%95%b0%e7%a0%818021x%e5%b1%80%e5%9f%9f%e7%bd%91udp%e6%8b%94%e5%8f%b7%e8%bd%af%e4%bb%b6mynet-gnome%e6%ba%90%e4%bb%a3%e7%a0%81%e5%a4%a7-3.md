title: [中秋零献] 神州数码802.1x局域网UDP拔号软件MyNet-Gnome源代码大分析（Part3）关键逻辑
link: http://www.54chen.com/_linux_/%e4%b8%ad%e7%a7%8b%e9%9b%b6%e7%8c%ae-%e7%a5%9e%e5%b7%9e%e6%95%b0%e7%a0%818021x%e5%b1%80%e5%9f%9f%e7%bd%91udp%e6%8b%94%e5%8f%b7%e8%bd%af%e4%bb%b6mynet-gnome%e6%ba%90%e4%bb%a3%e7%a0%81%e5%a4%a7-3.html
author: admin
description: 
post_id: 71
created: 2008/09/14 22:10:17
created_gmt: 2008/09/14 14:10:17
comment_status: open
post_name: %e4%b8%ad%e7%a7%8b%e9%9b%b6%e7%8c%ae-%e7%a5%9e%e5%b7%9e%e6%95%b0%e7%a0%818021x%e5%b1%80%e5%9f%9f%e7%bd%91udp%e6%8b%94%e5%8f%b7%e8%bd%af%e4%bb%b6mynet-gnome%e6%ba%90%e4%bb%a3%e7%a0%81%e5%a4%a7-3
status: publish
post_type: post

# [中秋零献] 神州数码802.1x局域网UDP拔号软件MyNet-Gnome源代码大分析（Part3）关键逻辑

/*** * Author: cc0cc * E-mail: cc0cc@126.com * WebSite: <http://www.54chen.com> * Date: the Mid-Autumn Festival of 2008 * FileName: callbacks.c * Description: callbacks.c为事件处理的核心逻辑，是MyNet的中心 ***/ #ifdef HAVE_CONFIG_H # include <config.h> #endif #include <gnome.h> #include "Mythread.h" #include "connect.h" #include "callbacks.h" #include "interface.h" #include "support.h" gchar line2[255];//用来存去掉回车后的字符串 void write_config(gchar *usr,gchar *pwd);//remember pwd void write_new_config();//first time to write config gchar * scape(gchar *line);//escapse the enter like '\n' /* * 关于mac和ip的：http://hi.baidu.com/cc0cc/blog/item/403cbb25a0cd9a6435a80fa7.html */ char *get_mac();//return the mac address char *get_ip();//get ip address int get_socket(); int tr_mac();//translate the mac address int CreateMutex();//a file like mutex （互斥体，用来保证只能同时运行一个此软件，后来被干掉啦：）） int trayshow; /*这个是window1，也就是软件一打开的时候会执行这个函数*/ void on_window1_show                        (GtkWidget       *widget,                                         gpointer         user_data) { /* //采访一下：为什么要把这段干掉？ //A：因为在程序异常关闭的时候，老是不能自己删除掉原来的PID文件，于是就得手工去删除，实在是不爽，干脆不限制了。 char runfile[1024]=""; FILE *runfp;    sprintf(runfile,"%s/.mynet/run.pid",getenv("HOME")); if((runfp = fopen(runfile, "r")) != NULL)     {        gtk_widget_hide(window1);     getAtrBox = create_messagebox("错误","程序已经运行了！",0);      gtk_widget_show (getAtrBox);     }else{         CreateMutex();         } */ username[0x40]=0; host[0x1E]=0; memcpy(host,SERVER,strlen((char *)SERVER)); mac_addr[0x20]=0; mac_Hex[6]=0; ip_addr[0x20]=0; passwd[0x40]=0; server_type[0x40]=0; memcpy(server_type,"internet",strlen((char *)"internet")); gchar *line = ((char *) malloc(255));//is 255b enough? char cfgfile[1024]=""; FILE *fp;        sprintf(cfgfile,"%s/.mynet/config",getenv("HOME")); if ((fp = fopen(cfgfile, "r")) == NULL)    write_new_config();//看出来这是在干什么了吗？这是把用户的当前设置给写进一个config文件，就算是windows里的注册表了 else     {     fgets(line,254,fp);     gtk_entry_set_text ((GtkEntry *)entry1,(const gchar *)scape(line));     memcpy(username,scape(line),strlen(scape(line)));     fgets(line,254,fp);     gtk_entry_set_text ((GtkEntry *)entry2,(const gchar *)scape(line));        memcpy(passwd,scape(line),strlen(scape(line)));     fgets(line,254,fp);     memcpy(ip_addr,scape(line),strlen(scape(line)));     fgets(line,254,fp);     memcpy(host,scape(line),strlen(scape(line)));g_message("here1");     //get_socket((char *)scape(line));//host to         g_message("%c",&line);     fgets(line,254,fp);g_message("here3");     memcpy(mac_addr,scape(line),strlen(scape(line)));g_message("here4");     tr_mac();g_message("here5");     }    g_message("mem now here:usr:%s\npwd:%s\nip:%s\nmac:%s\nserver:%s",username,passwd,ip_addr,mac_addr,host); free(line); } /*这是设置服务器的一个窗口*/ void on_window2_show                        (GtkWidget       *widget,                                         gpointer         user_data) {     gtk_entry_set_text ((GtkEntry *)entry3,(char *)ip_addr);     gtk_entry_set_text ((GtkEntry *)entry4,(char *)host);        gtk_combo_box_append_text (GTK_COMBO_BOX (comboboxentry1),(char *)mac_addr);     gtk_combo_box_set_active(GTK_COMBO_BOX (comboboxentry1),0);     } /*这个是哪个button?...是设置属性的那个按钮*/ void on_button3_clicked                     (GtkButton       *button,                                         gpointer         user_data) {     GtkWidget *mac_set;     mac_set = create_window2 ();      gtk_widget_show (mac_set);     return; } /* *这个是什么东东？ 记好了，这个在后面要用的，用来数数的计时的。 */ gint flash_timeout(gpointer data) {if(Acc_Keep_Link==-1){     gtk_widget_hide_all (linkwindow);     gtk_widget_show_all (window1);     getAtrBox = create_messagebox("提示","与网络连接中断！",1);      gtk_widget_show_all (getAtrBox);     return FALSE;     }     create_tray(tray);     return TRUE; } /*关键的一个来了！！这就是主界面中的连接按钮！主逻辑从它开始*/ void on_button1_clicked                     (GtkButton       *button,                                         gpointer         user_data) {    /*这个的意思是，如果连接的时候选择了记住密码，那么就要把用户名密码写进config文件去，不然的话就写个用户名得了*/ if(gtk_toggle_button_get_active((GtkToggleButton *)checkbutton1)) write_config((gchar *)gtk_entry_get_text ((GtkEntry *)entry1),             (gchar *)gtk_entry_get_text ((GtkEntry *)entry2)); else write_config((gchar *)gtk_entry_get_text ((GtkEntry *)entry1),             "");    gtk_widget_hide_all (window1);//所有窗口隐藏掉。。。 linkwindow = create_window3 ();//window3就是“请稍候”的那个窗口，大家都隐藏的时候它就要出来了 gtk_widget_show_all (linkwindow); gint ptimer_flash=0; gtk_timeout_remove(ptimer_flash); ptimer_flash=gtk_timeout_add(15000,flash_timeout,NULL);    //这是一个计时器，每1.5秒执行一次flash_timeout     pthread_t getaccess; Acc_Keep_Link=0; memcpy(username,(char *)gtk_entry_get_text ((GtkEntry *)entry1),strlen((char *)gtk_entry_get_text ((GtkEntry *)entry1))); memcpy(passwd,(char *)gtk_entry_get_text ((GtkEntry *)entry2),strlen((char *)gtk_entry_get_text ((GtkEntry *)entry2))); pthread_create(&getaccess,NULL,Access_Thread,NULL);//这会创建一个叫getaccess的线程 } /*垃圾按钮~~就是获取服务的那个按钮*/ void on_button4_clicked                     (GtkButton       *button,                                         gpointer         user_data) { memcpy(host,(char *)gtk_entry_get_text ((GtkEntry *)entry4),strlen((gchar *)gtk_entry_get_text ((GtkEntry *)entry4))); write_config((gchar *)gtk_entry_get_text ((GtkEntry *)entry1),             "");     get_socket((char *)gtk_entry_get_text ((GtkEntry *)entry4));     getAtrBox = create_messagebox("提示","恭喜，获取服务成功！",1);      gtk_widget_show (getAtrBox);     return;//sorry i can not understand what is this } /* * 当断开网络时会用 */ void before_quit                      (GtkWidget       *widget,                                         gpointer         user_data) { /* char cfgfile[1024]=""; sprintf(cfgfile,"%s/.mynet/run.pid",getenv("HOME")); unlink(cfgfile);//delete mutex file*/     if(gtk_toggle_button_get_active((GtkToggleButton *)checkbutton1)) write_config((gchar *)gtk_entry_get_text ((GtkEntry *)entry1),             (gchar *)gtk_entry_get_text ((GtkEntry *)entry2));//remember the passwd close(sockfd); gtk_main_quit(); } /*先说过的，用来写文件记录用户的基本信息的*/ void write_new_config() { int log; char filename[1024]; char log_string[1024]; char filepath[1024]; char *dir; strcpy(log_string,""); strcat(log_string,"\n");memcpy(username,"0",strlen((char *)username)); strcat(log_string,"\n");memcpy(passwd,"0",strlen((char *)passwd)); get_ip();    strcat(log_string,(char *)ip_addr);strcat(log_string,"\n"); strcat(log_string,SERVER);strcat(log_string,"\n"); get_mac();tr_mac();