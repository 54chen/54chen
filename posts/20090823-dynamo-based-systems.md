title: LinkIn基于Dynamo设计的系统：伏地魔(voldemort)设计中文文档[我是陈科学院译]-完稿
link: http://www.54chen.com/document/dynamo-based-systems.html
author: cc0cc
description: 
post_id: 736
created: 2009/08/23 23:00:54
created_gmt: 2009/08/23 15:00:54
comment_status: open
post_name: dynamo-based-systems
status: publish
post_type: post

# LinkIn基于Dynamo设计的系统：伏地魔(voldemort)设计中文文档[我是陈科学院译]-完稿

> 原文地址：http://project-voldemort.com/design.php 翻译：陈臻 http://www.54chen.com 我是陈科学院 版本：1.0 日期：2009-8-25

## Key-Value存储

为了实现高性能和高可用性，我们只允许非常简单的键值数据存取。key和value可以是list和map的复杂类型，但美中不足的是只有以下的查询是有效的： 

> 
>     value = store.get(key)
>     store.put(key, value)
>     store.delete(key)

这可不是解决了所有的问题，其实做了许多的取舍： 

### 缺点

没有复杂的查询过滤器 所有的联合查询必须在代码实现 没有外键的结构 没有触发器和视图 

### 优点

只有高效的查询可用，性能是可想像的 容易分布到集群 不管怎样，面向服务常常不允许外键的结构，并且强制在代码中实现联合（因为和数据相关的key这个关系 在另一个服务中维护着） 使用关系型数据库你必须要有一个缓存层用来扩展读操作，不过这个缓存层很典型地强制你使用了key-value的存储系统 为了性能，最后不得不使用xml或者是其他不够正规的一砣文本 使逻辑和存储分离清晰（出于性能原因，SQL鼓励将商业逻辑和存储操作混在一起） 没有对象-关系数据的丢失匹配问题 数据模型的详细的讨论将在下面给出。 

## 系统架构

代码中的每层实现了简单的put get和delete操作的接口。每一层都会负责一个方法，诸如tcp/ip网络通信、序列化、版本冲突解决、内部结点路由等等。例如路由层负责发起一个操作，比方说是Put，并且分发给N个存储并行执行复制，同是要捕获所有的失败。 ![](http://project-voldemort.com/images/logical_arch.png)图1 保持每一层独立意味着可以混合和匹配使用以满足运行中不同的需求。例如，我们可以增加一个压缩层，将字节值的压缩水平降低到序列化之下。同样，在将数据路由到分区的时候我们可以做灵活的智能路由。硬件负载均衡的http客户端（用ruby写的）这项工作可以在客户端做（smart的客户端），也可以在服务端做成傻瓜式的使用。要把网络层放在路由层的上面还是下面，我们需要做的是一件简单的事情。 ![](http://project-voldemort.com/images/physical_arch.png)图2 在上图中“Load Bal.”是指负载均衡的硬件或者是轮循软件负载均衡器，“Partition-aware routing”是存储的内部路由。从传延迟角度来看，越少的跳是件好事（因为，嗯，这样就跳得少了），从吞吐量的角度来说也是件好事（因为可预见的瓶颈更少了），但是需要把路由信息放到栈顶（例如，客户端必须是java的而且还要使用我们的库）。最后，最右的图中，http-rpc发送到服务的请求被路由到了包含正确数据的机器（如果有的话），因此，在一个单独的复制读的简单的情况下，机器必须能够直接从本地bdb线程内部获取数据。 这一灵活性使得高性能的配置成为可能。在存储中，磁盘的访问是一个独立的最大的性能冲击，第二个是网络的跳数。靠分区数据和尽可能缓存数据，可以避免磁盘访问。网络跳数需要架构的灵活性来消除。请注意在上图中，我们可以用不同的配置文件来执行3跳2跳和1跳的远程服务。要获得非常高的性能，就必须路由服务直接找到正确的服务器。 

### 数据分区和复制

数据必须分区到一个集群的所有服务器上，使没有任何一台单一的服务器需要保存所有的数据集。即便数据可以在一个单独的磁盘上存下，磁盘访问小值数据的时候是受寻找时候所控制，因此分区有改善缓存性能的作用，它依靠把热的数据集分成更小的块，能够（希望能够）整个地放到那个存有整个分区的服务器内存里。这就意味着，在集群里的机器是不可以互换的，请求必须被路由到保存有所请求的数据的机器，而不只是随便地到某一台可用的机器上。 同样，因为负载过重或者是维护原因的停机，服务器经常会不可用。如果有S台机器并且每台机器一天有p的概率会独自挂掉，因此一天里一台机器丢失数据的概率为1 - (1 - _p_)_s_，显然，鉴于这一事实，我们不能将数据只保存在一台机器上，或者说，数据丢失的概率与群集中的数量成反比。 最简单的方式来完成这件事是，将数据分成S个分区（每个机器一个），并且在R台机器上面保存键为K的值的拷贝。用K这个键来关联R台机器的一种方法是，设a=K%S，然后将这个值保存在机器a，a+1，a+2，...a+r。因此，对于任何的概率p，你都可以选择一个合适的复制因子R，来达到一个可接受的够低的数据丢失的概率。 这个系统有个非常漂亮的特性，那就是任何人只要知道数据的key就可以计算到数据所处的位置，系统允许我们以peer-to-peer的方式做数据寻找，而不需要联系一个装有所有的key到服务器的映射信息的中央元数据服务器。 当从集群中添加、删除机器时（这样说是因为我们购买新的硬件或服务器临时关闭），上述方法会导致缺点。在这种情况下，d会被改变，数据会在机器之间迁移。假如d不变，那负载不会平均地从原来删除的或者是坏了的机器分布到集群中剩余的部分。 一致性哈希是一种避免这种问题的技术，我们用它来计算每个key在集群中所处的位置。使用这种技术，伏地魔有了这样的特性，当一台机器挂了的时候，负载可以平均地分布到集群中剩余的机器。同样，当增加一台机器给一个有S台机器的集群时，只有1/(_S_+1)的机器上的值需要迁移到新机器。 为了形象化一致性哈希方法，我们可以看到，用可能出现的整数哈希值，这样，环就从0开始，顺着环旋转到2^31-1。这个环被平均分成Q个分区，Q>>S，这样S个机器中的每个，都能分到Q/S个分区。一个key用任何一种哈希算法映射到环上，然后我们顺时针看分区找到第一个唯一的R节点，计算出一个负责这个key的R个所有机器的列表。下面这个图画出了ABCD四个机器的一个哈希环。箭头表示key映射到哈希环，结果给出当R为3时对应的保存了那个key的值的所有机器的列表。 ![](http://project-voldemort.com/images/hash_ring.png)图3 

## 数据格式化和查询

在关系数据库中的数据被分成二维表。在这里它的等价物是“存储”，如果数据不是必须成表，我们不使用字表结构（一个值可以包括列表，以及不需要考虑严格的关系型的映射）。每个key都有一个唯一的存储，并且每个key都最多只能有一个值。 

### 查询

伏地魔系统支持哈希表的语义，因此一个单独的值可以一次进行修改，同时可以按照主键查询。因为可以通过主键来切分，这使得通过机器做分布式非常简单。 请注意，虽然我们不支持一对多的关系，但我们支持把列表做为值，这样也就完成了同样的事情，因此存储一个合理数量的有关联的值成为可能。这相当于一个java.util.Map的值是一个java.util.List。在大多数情况下，这样不规范来做是一个巨大的性能改善，因为只需要一个单独的磁盘寻址过程。但对于非常大的一个一对多关系（例如，而一个key映射到数千万的value），必须保存在机器上，再通过游标慢吞吞地过一遍，这样子是不实际的。这（很少见），必须将他们分成子查询或以其他方式在应用层处理。

## Comments

**[bohr.qiu](#13600 "2011-06-18 14:46:56"):** 您好，请教一个问题，voldemort怎样选取一个好的分区算法呢，在加载或者减少节点时，能减少数据移动的开销。voldemort提供了一个随机生成分区的工具，这样随机的分区方式，性能如何？

**[54chen](#13604 "2011-06-20 20:10:51"):** 实际上要尽可能的减少分区移动的办法是尽可能地多分区，而往往分区越多逻辑越复杂，但数据的移动是必不可少的，voldermort的做法我记得是分大区，而不是尽可能分区，性能不好评价，在这样的系统里，普通的md5对都是可行的，由dynamo文档里的虚拟分区的方案来保证不浪费资源移动不需要移动的数据。

**[bohr.qiu](#13704 "2011-07-28 08:38:23"):** 谢谢，分区越多为什么会越来越复杂。当然路由会耗时一点，但是这样的在路由这块的性能消耗是可以接受的。 voldermort分大区的做法我觉得不太好。好像分区数是不会改变的吧？

**[54chen](#13705 "2011-07-28 11:36:28"):** 分区太多的时候配置管理是个麻烦事情，分区少的话配置很容易做。

**[xhttp](#11854 "2009-08-26 15:50:13"):** 经典 要顶一下才行

**[随网](#12067 "2009-12-22 10:47:14"):** 听到airia中，你的演讲 受益良多

**[cc0cc](#12068 "2009-12-22 21:14:04"):** 兄弟的idea真是不错，相当天才！佩服佩服

